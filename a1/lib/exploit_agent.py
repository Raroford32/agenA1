import asyncio
import json
import os
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
from datetime import datetime
import logging
from enum import Enum

from .grok_llm import GrokLLM, create_grok_client
from .ethereum_client import EthereumClient, ForkSimulator, create_ethereum_client

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ExploitStatus(Enum):
    PENDING = "pending"
    ANALYZING = "analyzing"
    PLANNING = "planning"
    SIMULATING = "simulating"
    EXECUTING = "executing"
    COMPLETED = "completed"
    FAILED = "failed"


@dataclass
class VulnerabilityReport:
    contract_address: str
    vulnerability_type: str
    severity: str
    description: str
    attack_vector: str
    estimated_profit_eth: float
    confidence_score: float
    details: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ExploitPlan:
    target_contract: str
    vulnerability: VulnerabilityReport
    steps: List[Dict[str, Any]]
    required_funds_eth: float
    expected_profit_eth: float
    gas_estimate: int
    exploit_contract_code: str
    simulation_results: Optional[Dict[str, Any]] = None


class ExploitAgent:
    def __init__(
        self,
        grok_client: GrokLLM,
        ethereum_client: EthereumClient,
        fork_block: Optional[int] = None
    ):
        self.grok = grok_client
        self.eth = ethereum_client
        self.fork_block = fork_block
        self.current_status = ExploitStatus.PENDING
        
    async def analyze_contract(
        self,
        contract_address: str
    ) -> List[VulnerabilityReport]:
        self.current_status = ExploitStatus.ANALYZING
        logger.info(f"Analyzing contract: {contract_address}")
        
        # Get contract code and ABI
        code = await self.eth.get_code(contract_address)
        if not code:
            raise ValueError(f"No code found at address {contract_address}")
            
        # Use Grok to analyze the contract
        analysis_prompt = f"""Analyze this Ethereum smart contract for vulnerabilities.
Contract address: {contract_address}
Bytecode length: {len(code)} bytes

Perform deep analysis for:
1. Reentrancy vulnerabilities
2. Integer overflow/underflow
3. Access control issues
4. Oracle manipulation opportunities
5. Flash loan attack vectors
6. MEV extraction opportunities
7. Price manipulation
8. Governance attacks

Provide detailed vulnerability reports with severity ratings and profit estimates."""

        response = await self.grok.generate(
            prompt=analysis_prompt,
            system_prompt="You are an expert Ethereum security auditor using Grok-4-0709 model.",
            temperature=0.3,
            response_format={"type": "json_object"}
        )
        
        analysis_result = json.loads(response.content)
        vulnerabilities = []
        
        for vuln in analysis_result.get("vulnerabilities", []):
            report = VulnerabilityReport(
                contract_address=contract_address,
                vulnerability_type=vuln.get("type", "Unknown"),
                severity=vuln.get("severity", "Medium"),
                description=vuln.get("description", ""),
                attack_vector=vuln.get("attack_vector", ""),
                estimated_profit_eth=float(vuln.get("estimated_profit_eth", 0)),
                confidence_score=float(vuln.get("confidence_score", 0.5)),
                details=vuln.get("details", {})
            )
            vulnerabilities.append(report)
            
        logger.info(f"Found {len(vulnerabilities)} vulnerabilities")
        return vulnerabilities
        
    async def plan_exploit(
        self,
        vulnerability: VulnerabilityReport
    ) -> ExploitPlan:
        self.current_status = ExploitStatus.PLANNING
        logger.info(f"Planning exploit for {vulnerability.vulnerability_type}")
        
        # Generate exploit plan using Grok
        planning_prompt = f"""Create a detailed exploit plan for this vulnerability:

Target: {vulnerability.contract_address}
Type: {vulnerability.vulnerability_type}
Attack Vector: {vulnerability.attack_vector}
Details: {json.dumps(vulnerability.details, indent=2)}

Generate:
1. Step-by-step exploit execution plan
2. Required initial funds
3. Expected profit calculation
4. Complete Solidity exploit contract code
5. Gas optimization strategies
6. Risk mitigation steps

The exploit must be executable on Ethereum mainnet."""

        response = await self.grok.generate(
            prompt=planning_prompt,
            system_prompt="You are Grok-4-0709, an expert exploit developer. Generate production-ready exploit code.",
            temperature=0.2,
            max_tokens=8192,
            response_format={"type": "json_object"}
        )
        
        plan_data = json.loads(response.content)
        
        # Extract Solidity code
        exploit_code = plan_data.get("exploit_contract", "")
        if not exploit_code and "solidity_code" in plan_data:
            exploit_code = plan_data["solidity_code"]
            
        plan = ExploitPlan(
            target_contract=vulnerability.contract_address,
            vulnerability=vulnerability,
            steps=plan_data.get("steps", []),
            required_funds_eth=float(plan_data.get("required_funds_eth", 0)),
            expected_profit_eth=float(plan_data.get("expected_profit_eth", 0)),
            gas_estimate=int(plan_data.get("gas_estimate", 3000000)),
            exploit_contract_code=exploit_code
        )
        
        logger.info(f"Exploit plan created: {plan.expected_profit_eth} ETH expected profit")
        return plan
        
    async def simulate_exploit(
        self,
        plan: ExploitPlan,
        fork_rpc_url: str = "http://localhost:8545"
    ) -> Dict[str, Any]:
        self.current_status = ExploitStatus.SIMULATING
        logger.info("Simulating exploit on forked mainnet")
        
        # Create fork client
        fork_client = create_ethereum_client(fork_rpc_url)
        await fork_client.initialize()
        
        simulator = ForkSimulator(fork_client, self.fork_block or await self.eth.get_block_number())
        
        # Create simulation account
        simulation_account = "0x" + "1" * 40
        await simulator.impersonate_account(simulation_account)
        await simulator.set_balance(
            simulation_account,
            int(plan.required_funds_eth * 10**18 * 1.5)  # 50% buffer
        )
        
        # Take snapshot
        snapshot_id = await simulator.snapshot()
        
        try:
            # Deploy exploit contract
            # Note: This would require compiling the Solidity code first
            logger.info("Deploying exploit contract in simulation")
            
            # Execute exploit steps
            results = {
                "success": False,
                "profit_eth": 0,
                "gas_used": 0,
                "transactions": [],
                "errors": []
            }
            
            for i, step in enumerate(plan.steps):
                logger.info(f"Executing step {i+1}: {step.get('description', 'Unknown')}")
                
                # Simulate step execution
                # This would involve calling the appropriate functions
                
            # Calculate final profit
            final_balance = await fork_client.get_balance(simulation_account)
            initial_balance = int(plan.required_funds_eth * 10**18 * 1.5)
            profit_wei = final_balance - initial_balance
            results["profit_eth"] = profit_wei / 10**18
            results["success"] = results["profit_eth"] > 0
            
            logger.info(f"Simulation complete: {'Success' if results['success'] else 'Failed'}")
            logger.info(f"Simulated profit: {results['profit_eth']} ETH")
            
        except Exception as e:
            logger.error(f"Simulation failed: {e}")
            results["errors"].append(str(e))
            
        finally:
            # Revert to snapshot
            await simulator.revert(snapshot_id)
            
        plan.simulation_results = results
        return results
        
    async def execute_exploit(
        self,
        plan: ExploitPlan,
        private_key: str,
        execute_live: bool = False
    ) -> Dict[str, Any]:
        if not execute_live:
            logger.warning("Live execution disabled. Set execute_live=True to execute on mainnet.")
            return {"status": "aborted", "reason": "Live execution disabled"}
            
        if not plan.simulation_results or not plan.simulation_results.get("success"):
            raise ValueError("Cannot execute exploit without successful simulation")
            
        self.current_status = ExploitStatus.EXECUTING
        logger.info("Executing exploit on mainnet")
        
        execution_results = {
            "status": "pending",
            "transactions": [],
            "total_gas_used": 0,
            "total_profit_eth": 0,
            "errors": []
        }
        
        try:
            # Deploy exploit contract
            logger.info("Deploying exploit contract")
            
            # Execute exploit
            for i, step in enumerate(plan.steps):
                logger.info(f"Executing step {i+1}: {step.get('description', 'Unknown')}")
                
                # Execute transaction
                # tx_hash = await self.eth.send_transaction(...)
                # receipt = await self.eth.wait_for_transaction_receipt(tx_hash)
                
            execution_results["status"] = "completed"
            self.current_status = ExploitStatus.COMPLETED
            
        except Exception as e:
            logger.error(f"Execution failed: {e}")
            execution_results["status"] = "failed"
            execution_results["errors"].append(str(e))
            self.current_status = ExploitStatus.FAILED
            
        return execution_results
        
    async def run_full_pipeline(
        self,
        contract_address: str,
        private_key: Optional[str] = None,
        execute_live: bool = False
    ) -> Dict[str, Any]:
        logger.info(f"Starting full exploit pipeline for {contract_address}")
        
        results = {
            "contract_address": contract_address,
            "timestamp": datetime.now().isoformat(),
            "vulnerabilities": [],
            "exploits": [],
            "total_profit_eth": 0
        }
        
        try:
            # Step 1: Analyze contract
            vulnerabilities = await self.analyze_contract(contract_address)
            results["vulnerabilities"] = [
                {
                    "type": v.vulnerability_type,
                    "severity": v.severity,
                    "estimated_profit_eth": v.estimated_profit_eth,
                    "confidence_score": v.confidence_score
                }
                for v in vulnerabilities
            ]
            
            # Step 2: Plan and simulate exploits
            for vuln in vulnerabilities:
                if vuln.confidence_score < 0.7:
                    logger.info(f"Skipping low confidence vulnerability: {vuln.vulnerability_type}")
                    continue
                    
                try:
                    # Plan exploit
                    plan = await self.plan_exploit(vuln)
                    
                    # Simulate exploit
                    simulation_results = await self.simulate_exploit(plan)
                    
                    exploit_result = {
                        "vulnerability_type": vuln.vulnerability_type,
                        "planned_profit_eth": plan.expected_profit_eth,
                        "simulated_profit_eth": simulation_results.get("profit_eth", 0),
                        "simulation_success": simulation_results.get("success", False)
                    }
                    
                    # Execute if profitable and authorized
                    if (simulation_results.get("success") and 
                        simulation_results.get("profit_eth", 0) > 0.1 and  # Min 0.1 ETH profit
                        private_key and execute_live):
                        
                        execution_results = await self.execute_exploit(plan, private_key, execute_live)
                        exploit_result["execution_results"] = execution_results
                        
                        if execution_results.get("status") == "completed":
                            results["total_profit_eth"] += execution_results.get("total_profit_eth", 0)
                            
                    results["exploits"].append(exploit_result)
                    
                except Exception as e:
                    logger.error(f"Failed to exploit {vuln.vulnerability_type}: {e}")
                    
        except Exception as e:
            logger.error(f"Pipeline failed: {e}")
            results["error"] = str(e)
            
        return results


async def create_exploit_agent(
    grok_api_key: Optional[str] = None,
    eth_rpc_url: Optional[str] = None,
    fork_block: Optional[int] = None
) -> ExploitAgent:
    # Initialize Grok client
    grok_client = create_grok_client(grok_api_key)
    
    # Initialize Ethereum client
    eth_client = create_ethereum_client(eth_rpc_url)
    await eth_client.initialize()
    
    # Create agent
    agent = ExploitAgent(grok_client, eth_client, fork_block)
    
    return agent